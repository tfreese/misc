/*
 * (c) 2004, Nuno Santos, nfsantos@sapo.pt relased under terms of the GNU public license
 * http://www.gnu.org/licenses/licenses.html#TOCGPL
 */
package de.freese.nio.beispiele.nuno.handlers;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;

import de.freese.nio.beispiele.nuno.io.ProtocolDecoder;
import de.freese.nio.beispiele.nuno.io.ReadWriteSelectorHandler;
import de.freese.nio.beispiele.nuno.io.SelectorThread;

/**
 * Uses non-blocking operations to read and write from a socket. Internally, this class uses a
 * selector to receive read and write events from the underlying socket. Methods on this class
 * should be called only by the selector's thread (including the constructor). If necessary, use
 * Selector.invokeLater() to dispatch a invocation to the selector's thread.
 * 
 * @author Nuno Santos
 */
final public class PacketChannel implements ReadWriteSelectorHandler
{
	/** The associated selector. */
	protected final SelectorThread selector;

	/** The socket where read and write operations are performed. */
	private final SocketChannel sc;

	/** Used for reading from the socket. */
	private ByteBuffer inBuffer;

	/**
	 * The buffer with the packet currently being sent. This class can only send one packet at a
	 * time, there are no queueing mechanisms.
	 */
	private ByteBuffer outBuffer = null;

	/**
	 * Used to convert raw bytes into packets. (Strategy design pattern)
	 */
	private final ProtocolDecoder protocolDecoder;

	/**
	 * Object interested in the events generated by this class. It is notified whenever an error
	 * occurs or a packet is read.
	 */
	private final PacketChannelListener listener;

	/**
	 * Creates and initializes a new instance. Read interest is enabled by the constructor, so
	 * callers should be ready to star receiving packets.
	 * 
	 * @param socketChannel Socket to be wrapped.
	 * @param selector Selector to be used for managing IO events.
	 * @param listener Object to receive the callbacks.
	 * @param protocolDecoder Decoder for reassembling the packets.
	 * @throws IOException Falls was schief geht.
	 */
	public PacketChannel(final SocketChannel socketChannel, final SelectorThread selector,
			final ProtocolDecoder protocolDecoder, final PacketChannelListener listener)
		throws IOException
	{
		super();

		this.selector = selector;
		this.protocolDecoder = protocolDecoder;
		this.sc = socketChannel;
		this.listener = listener;

		// Creates the reading buffer
		// The size is the same as the size of the TCP sockets receive buffer.
		// We will never read more than that at a time.
		this.inBuffer = ByteBuffer.allocateDirect(this.sc.socket().getReceiveBufferSize());

		// Quick and dirty hack. When a buffer is created by the first time
		// it is empty, with
		this.inBuffer.position(this.inBuffer.capacity());

		// inBuffer.flip();

		// Registers with read interest.
		selector.registerChannelNow(this.sc, 0, this);
	}

	/**
 * 
 */
	public void close()
	{
		try
		{
			this.sc.close();
		}
		catch (IOException ex)
		{
			// Ignore
		}
	}

	/**
	 * Disable interest in reading.
	 * 
	 * @throws IOException Falls was schief geht.
	 */
	public void disableReading() throws IOException
	{
		this.selector.removeChannelInterestNow(this.sc, SelectionKey.OP_READ);
	}

	/**
	 * @return {@link SocketChannel}
	 */
	public SocketChannel getSocketChannel()
	{
		return this.sc;
	}

	/**
	 * Reads from the socket into the internal buffer. This method should be called only from the
	 * SelectorThread class.
	 */
	@Override
	public void handleRead()
	{
		try
		{
			// Reads from the socket
			// Returns -1 if it has reached end-of-stream
			int readBytes = this.sc.read(this.inBuffer);
			// End of stream???
			if (readBytes == -1)
			{
				// End of stream. Closing channel...
				close();
				this.listener.socketDisconnected(this);
				return;
			}

			// Nothing else to be read?
			if (readBytes == 0)
			{
				// There was nothing to read. Shouldn't happen often, but
				// it is not an error, we can deal with it. Ignore this event
				// and reactivate reading.
				reactivateReading();
				return;
			}

			// There is some data in the buffer. Processes it.
			this.inBuffer.flip();
			processInBuffer();
		}
		catch (IOException ex)
		{
			// Serious error. Close socket.
			this.listener.socketException(this, ex);
			close();
		}
	}

	/**
	 * Writes to the underlying channel. Non-blocking. This method is called only from sendPacket()
	 * and from the SelectorThread class.
	 */
	@Override
	public void handleWrite()
	{
		try
		{
			// Writes to the socket as much as possible. Since this is a
			// non-blocking operation, we don't know in advance how many
			// bytes will actually be written.
			// int written =
			this.sc.write(this.outBuffer);

			// Check if there are more to be written.
			if (this.outBuffer.hasRemaining())
			{
				// There is. Reactivate interest in writing. We will try again
				// when the socket is ready.
				requestWrite();
			}
			else
			{
				// outBuffer was completly written. Notifies listener
				ByteBuffer sentPacket = this.outBuffer;
				this.outBuffer = null;
				this.listener.packetSent(this, sentPacket);
			}
		}
		catch (IOException ioe)
		{
			close();
			this.listener.socketException(this, ioe);
		}
	}

	/**
	 * Processes the internal buffer, converting it into packets if enough data is available.
	 * 
	 * @throws IOException Falls was schief geht.
	 */
	private void processInBuffer() throws IOException
	{
		ByteBuffer packet = this.protocolDecoder.decode(this.inBuffer);
		// A packet may or may not have been fully assembled, depending
		// on the data available in the buffer
		if (packet == null)
		{
			// Partial packet received. Must wait for more data. All the contents
			// of inBuffer were processed by the protocol decoder. We can
			// delete it and prepare for more data.
			this.inBuffer.clear();
			reactivateReading();
		}
		else
		{
			// A packet was reassembled.
			this.listener.packetArrived(this, packet);
			// The inBuffer might still have some data left. Perhaps
			// the beginning of another packet. So don't clear it. Next
			// time reading is activated, we start by processing the inBuffer
			// again.
		}
	}

	/**
	 * Enables interest in reading.
	 * 
	 * @throws IOException Falls was schief geht.
	 */
	private void reactivateReading() throws IOException
	{
		this.selector.addChannelInterestNow(this.sc, SelectionKey.OP_READ);
	}

	/**
	 * Activates interest in writing.
	 * 
	 * @throws IOException Falls was schief geht.
	 */
	private void requestWrite() throws IOException
	{
		this.selector.addChannelInterestNow(this.sc, SelectionKey.OP_WRITE);
	}

	/**
	 * Activates reading from the socket. This method is non-blocking.
	 * 
	 * @throws IOException Falls was schief geht.
	 */
	public void resumeReading() throws IOException
	{
		processInBuffer();
	}

	/**
	 * Sends a packet using non-blocking writes. One packet cannot be sent before the previous one
	 * has been dispatched. The caller must ensure this. This class keeps a reference to buffer
	 * given as argument while sending it. So it is important not to change this buffer after
	 * calling this method.
	 * 
	 * @param packet The packet to be sent.
	 */
	public void sendPacket(final ByteBuffer packet)
	{
		// keeps a reference to the packet. In production code this should copy
		// the contents of the buffer.
		this.outBuffer = packet;
		handleWrite();
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString()
	{
		return Integer.toString(this.sc.socket().getLocalPort());
	}
}